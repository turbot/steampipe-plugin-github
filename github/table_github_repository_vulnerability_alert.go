package github

import (
	"context"
	"fmt"
	"github.com/shurcooL/githubv4"
	"github.com/turbot/steampipe-plugin-github/github/models"
	"github.com/turbot/steampipe-plugin-sdk/v5/grpc/proto"
	"github.com/turbot/steampipe-plugin-sdk/v5/plugin"
	"github.com/turbot/steampipe-plugin-sdk/v5/plugin/transform"
)

func tableGitHubRepositoryVulnerabilityAlert() *plugin.Table {
	return &plugin.Table{
		Name:        "github_repository_vulnerability_alert",
		Description: "Vulnerability Alerts from a repository.",
		List: &plugin.ListConfig{
			Hydrate:           tableGitHubRepositoryVulnerabilityList,
			ShouldIgnoreError: isNotFoundError([]string{"404"}),
			KeyColumns: []*plugin.KeyColumn{
				{
					Name:    "repository_full_name",
					Require: plugin.Required,
				},
				{
					Name:       "state",
					Require:    plugin.Optional,
					CacheMatch: "exact",
				},
			},
		},
		Columns: gitHubRepositoryVulnerabilityAlertColumns(),
	}
}

func tableGitHubRepositoryVulnerabilityList(ctx context.Context, d *plugin.QueryData, h *plugin.HydrateData) (interface{}, error) {
	q := d.EqualsQuals
	fullName := q["repository_full_name"].GetStringValue()
	owner, repoName := parseRepoFullName(fullName)
	s := q["state"].GetStringValue()
	states := []githubv4.RepositoryVulnerabilityAlertState{
		githubv4.RepositoryVulnerabilityAlertStateOpen,
		githubv4.RepositoryVulnerabilityAlertStateFixed,
		githubv4.RepositoryVulnerabilityAlertStateDismissed,
	}

	if s != "" {
		switch s {
		case "OPEN":
			states = []githubv4.RepositoryVulnerabilityAlertState{githubv4.RepositoryVulnerabilityAlertStateOpen}
		case "FIXED":
			states = []githubv4.RepositoryVulnerabilityAlertState{githubv4.RepositoryVulnerabilityAlertStateFixed}
		case "DISMISSED":
			states = []githubv4.RepositoryVulnerabilityAlertState{githubv4.RepositoryVulnerabilityAlertStateDismissed}
		default:
			return nil, fmt.Errorf("state must be 'OPEN', 'FIXED' or 'DISMISSED' you provided '%s' which is invalid", s)
		}
	}

	pageSize := adjustPageSize(100, d.QueryContext.Limit)
	variables := map[string]interface{}{
		"owner":    githubv4.String(owner),
		"repo":     githubv4.String(repoName),
		"pageSize": githubv4.Int(pageSize),
		"cursor":   (*githubv4.String)(nil),
		"states":   states,
	}
	var query struct {
		RateLimit  models.RateLimit
		Repository struct {
			VulnerabilityAlerts struct {
				TotalCount int
				PageInfo   models.PageInfo
				Nodes      []models.RepositoryVulnerabilityAlert
			} `graphql:"vulnerabilityAlerts(first: $pageSize, after: $cursor, states: $states)"`
		} `graphql:"repository(owner: $owner, name: $repo)"`
	}

	client := connectV4(ctx, d)
	listPage := func(ctx context.Context, d *plugin.QueryData, h *plugin.HydrateData) (interface{}, error) {
		return nil, client.Query(ctx, &query, variables)
	}

	for {
		_, err := plugin.RetryHydrate(ctx, d, h, listPage, retryConfig())
		plugin.Logger(ctx).Debug(rateLimitLogString("github_repository_collaborator", &query.RateLimit))
		if err != nil {
			plugin.Logger(ctx).Error("github_repository_collaborator", "api_error", err, "repository", fullName)
			return nil, err
		}

		for _, c := range query.Repository.VulnerabilityAlerts.Nodes {
			d.StreamListItem(ctx, c)

			// Context can be cancelled due to manual cancellation or the limit has been hit
			if d.RowsRemaining(ctx) == 0 {
				return nil, nil
			}
		}

		if !query.Repository.VulnerabilityAlerts.PageInfo.HasNextPage {
			break
		}
		variables["cursor"] = githubv4.NewString(query.Repository.VulnerabilityAlerts.PageInfo.EndCursor)
	}

	return nil, nil
}

func gitHubRepositoryVulnerabilityAlertColumns() []*plugin.Column {
	return []*plugin.Column{
		{Name: "repository_full_name", Type: proto.ColumnType_STRING, Description: "The full name of the repository, including the owner and repo name.", Transform: transform.FromQual("repository_full_name")},
		{Name: "number", Type: proto.ColumnType_INT, Transform: transform.FromField("Number", "Node.Number"), Description: "Number of vulnerability alert."},
		{Name: "node_id", Type: proto.ColumnType_STRING, Transform: transform.FromField("NodeId", "Node.NodeId"), Description: "The node id of the vulnerability alert."},
		{Name: "auto_dismissed_at", Type: proto.ColumnType_TIMESTAMP, Transform: transform.FromField("AutoDismissedAt", "Node.AutoDismissedAt").NullIfZero().Transform(convertTimestamp), Description: "Timestamp at which the vulnerability alert was automatically dismissed."},
		{Name: "created_at", Type: proto.ColumnType_TIMESTAMP, Transform: transform.FromField("CreatedAt", "Node.CreatedAt").NullIfZero().Transform(convertTimestamp), Description: "Timestamp when the vulnerability alert was created."},
		{Name: "dependency_scope", Type: proto.ColumnType_STRING, Transform: transform.FromField("DependencyScope", "Node.DependencyScope"), Description: "The dependency scope of the vulnerability alert, will be RUNTIME or DEVELOPMENT."},
		{Name: "dismiss_comment", Type: proto.ColumnType_STRING, Transform: transform.FromField("DismissComment", "Node.DismissComment"), Description: "Comment on the dismissal of the vulnerability alert."},
		{Name: "dismiss_reason", Type: proto.ColumnType_STRING, Transform: transform.FromField("DismissReason", "Node.DismissReason"), Description: "Reason for the dismissal of the vulnerability alert."},
		{Name: "dismissed_at", Type: proto.ColumnType_TIMESTAMP, Transform: transform.FromField("DismissedAt", "Node.DismissedAt").NullIfZero().Transform(convertTimestamp), Description: "Timestamp at which the vulnerability alert was dismissed."},
		{Name: "dismisser", Type: proto.ColumnType_JSON, Transform: transform.FromField("Dismisser", "Node.Dismisser"), Description: "The user whom dismissed the vulnerability alert."},
		{Name: "fixed_at", Type: proto.ColumnType_TIMESTAMP, Transform: transform.FromField("FixedAt", "Node.FixedAt").NullIfZero().Transform(convertTimestamp), Description: "Timestamp when the vulnerability alert was marked as fixed."},
		{Name: "state", Type: proto.ColumnType_STRING, Transform: transform.FromField("State", "Node.State"), Description: "State of the vulnerability alert, will be 'OPEN', 'FIXED' or 'DISMISSED'."},
		{Name: "security_advisory", Type: proto.ColumnType_JSON, Transform: transform.FromField("SecurityAdvisory", "Node.SecurityAdvisory"), Description: "The security advisory associated with the vulnerability alert."},
		{Name: "security_vulnerability", Type: proto.ColumnType_JSON, Transform: transform.FromField("SecurityVulnerability", "Node.SecurityVulnerability"), Description: "The vulnerability associated with the vulnerability alert."},
		{Name: "vulnerable_manifest_filename", Type: proto.ColumnType_STRING, Transform: transform.FromField("VulnerableManifestFilename", "Node.VulnerableManifestFilename"), Description: "Filename of the vulnerable manifest."},
		{Name: "vulnerable_manifest_path", Type: proto.ColumnType_STRING, Transform: transform.FromField("VulnerableManifestPath", "Node.VulnerableManifestPath"), Description: "Path of the vulnerable manifest."},
		{Name: "vulnerable_requirements", Type: proto.ColumnType_STRING, Transform: transform.FromField("VulnerableRequirements", "Node.VulnerableRequirements"), Description: "Vulnerable requirements from the manifest."},
		// Promoted Fields
		{Name: "severity", Type: proto.ColumnType_STRING, Transform: transform.FromField("SecurityVulnerability.Severity", "Node.SecurityVulnerability.Severity"), Description: "Severity of the vulnerability."},
		{Name: "cvss_score", Type: proto.ColumnType_DOUBLE, Transform: transform.FromField("SecurityAdvisory.Cvss.Score", "Node.SecurityAdvisory.Cvss.Score"), Description: "The CVSS score of the advisory associated with the vulnerability alert."},
	}
}
